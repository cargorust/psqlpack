use ast::*;
use lexer::{self};

grammar<'input>;

extern {
    enum lexer::Token {
        "(" => lexer::Token::LeftBracket,
        ")" => lexer::Token::RightBracket,
        "," => lexer::Token::Comma,
        ";" => lexer::Token::Semicolon,
        "=" => lexer::Token::Equals,
        "." => lexer::Token::Period,

        BIGINT => lexer::Token::BIGINT,
        BIGSERIAL => lexer::Token::BIGSERIAL,
        BIT => lexer::Token::BIT,
        BOOL => lexer::Token::BOOL,
        BOOLEAN => lexer::Token::BOOLEAN,
        CONSTRAINT => lexer::Token::CONSTRAINT,
        CHAR => lexer::Token::CHAR,
        CHARACTER => lexer::Token::CHARACTER,
        CREATE => lexer::Token::CREATE,
        DATE => lexer::Token::DATE,
        DOUBLE => lexer::Token::DOUBLE,
        FILLFACTOR => lexer::Token::FILLFACTOR,
        FOREIGN => lexer::Token::FOREIGN,
        INT => lexer::Token::INT,
        INT2 => lexer::Token::INT2,
        INT4 => lexer::Token::INT4,
        INT8 => lexer::Token::INT8,
        INTEGER => lexer::Token::INTEGER,
        KEY => lexer::Token::KEY,
        MONEY => lexer::Token::MONEY,
        NOT => lexer::Token::NOT,
        NULL => lexer::Token::NULL,
        NUMERIC => lexer::Token::NUMERIC,
        PRECISION => lexer::Token::PRECISION,
        PRIMARY => lexer::Token::PRIMARY,
        REAL => lexer::Token::REAL,
        REFERENCES => lexer::Token::REFERENCES,
        SERIAL => lexer::Token::SERIAL,
        SERIAL2 => lexer::Token::SERIAL2,
        SERIAL4 => lexer::Token::SERIAL4,
        SERIAL8 => lexer::Token::SERIAL8,
        SMALLINT => lexer::Token::SMALLINT,
        SMALLSERIAL => lexer::Token::SMALLSERIAL,
        TABLE => lexer::Token::TABLE,
        TEXT => lexer::Token::TEXT,
        TIME => lexer::Token::TIME,
        TIMESTAMP => lexer::Token::TIMESTAMP,
        TIMESTAMPTZ => lexer::Token::TIMESTAMPTZ,
        TIMETZ => lexer::Token::TIMETZ,
        UNIQUE => lexer::Token::UNIQUE,
        UUID => lexer::Token::UUID,
        VARBIT => lexer::Token::VARBIT,
        VARCHAR => lexer::Token::VARCHAR,
        VARYING => lexer::Token::VARYING,
        WITH => lexer::Token::WITH,
        WITHOUT => lexer::Token::WITHOUT,
        ZONE => lexer::Token::ZONE,
        
        Ident => lexer::Token::Identifier(<String>),
        Digit => lexer::Token::Digit(<i32>),
    }
}

pub statement_list: Vec<Statement> = {
    <v:statement_list> <stmt:statement> => {
        let mut v = v;
        v.push(stmt);
        v
    },
    <statement> => vec!(<>),
};

statement: Statement = {
    CREATE TABLE <name:table_name> "(" <columns:column_definition_list> "," <constraints:constraint_list> ")" ";"? => Statement::Table(TableDefinition {
        name: name,
        columns: columns,
        constraints: Some(constraints),
    }),
    CREATE TABLE <name:table_name> "(" <columns:column_definition_list> ")" ";"? => Statement::Table(TableDefinition {
        name: name,
        columns: columns,
        constraints: None,
    }),
};

table_name: TableName = {
    <schema:Ident> "." <name:Ident> => TableName { schema: Some(schema), name: name },
    <name:Ident> => TableName { schema: None, name: name },
};

column_definition_list: Vec<ColumnDefinition> = {
    <v:column_definition_list> "," <c:column_definition> => {
        let mut v = v;
        v.push(c);
        v
    },
    <column_definition> => vec!(<>)
};

column_definition: ColumnDefinition = {
    <name:Ident> <t:sql_type> <qualifiers:qualifier_list?> => ColumnDefinition {
        name: name,
        sql_type: t,
        qualifiers: qualifiers,
    },
};

column_list: Vec<String> = {
    <v:column_list> "," <c:Ident> => {
        let mut v = v;
        v.push(c);
        v
    },
    <Ident> => vec!(<>),
};

constraint_list: Vec<Constraint> = {
    <v:constraint_list> "," <c:constraint> => {
        let mut v = v;
        v.push(c);
        v
    },
    <constraint> => vec!(<>),
};

constraint: Constraint = {
    CONSTRAINT <name:Ident> PRIMARY KEY "(" <columns:column_list> ")" <options:index_options?> => Constraint::Primary { 
        name: name, 
        columns: columns, 
        options: options 
    },
    CONSTRAINT <name:Ident> FOREIGN KEY "(" <columns:column_list> ")" REFERENCES <ref_table:table_name> "(" <ref_columns:column_list> ")" => Constraint::Foreign { 
        name: name, 
        columns: columns, 
        ref_table: ref_table, 
        ref_columns: ref_columns 
    }, 
};

index_options: Vec<IndexOption> = {
    WITH "(" <index_option_list> ")" => <>,
};

index_option_list: Vec<IndexOption> = {
    <v:index_option_list> "," <i:index_option> => {
        let mut v = v;
        v.push(i);
        v
    },
    <index_option> => vec!(<>),
};

index_option: IndexOption = {
    FILLFACTOR "=" <Digit> => IndexOption::FillFactor(<> as u32),
};

sql_type: SqlType = {
    CHAR "(" <Digit> ")" => SqlType::FixedLengthString(<> as u32),
    CHARACTER "(" <Digit> ")" => SqlType::FixedLengthString(<> as u32),
    VARCHAR "(" <Digit> ")" => SqlType::VariableLengthString(<> as u32),
    CHARACTER VARYING "(" <Digit> ")" => SqlType::VariableLengthString(<> as u32),
    TEXT => SqlType::Text,

    BIT "(" <Digit> ")" => SqlType::FixedLengthBitString(<> as u32),
    VARBIT "(" <Digit> ")" => SqlType::VariableLengthBitString(<> as u32),
    BIT VARYING "(" <Digit> ")" => SqlType::VariableLengthBitString(<> as u32),
    SMALLINT => SqlType::SmallInteger,
    INT => SqlType::Integer,
    INTEGER => SqlType::Integer,
    BIGINT => SqlType::BigInteger,
    INT2 => SqlType::SmallInteger,
    INT4 => SqlType::Integer,
    INT8 => SqlType::BigInteger,

    SMALLSERIAL => SqlType::SmallSerial,
    SERIAL => SqlType::Serial,
    BIGSERIAL => SqlType::BigSerial,
    SERIAL2 => SqlType::SmallSerial,
    SERIAL4 => SqlType::Serial,
    SERIAL8 => SqlType::BigSerial,

    NUMERIC "(" <m:Digit> "," <d:Digit> ")" => SqlType::Numeric(m as u32, d as u32),
    DOUBLE PRECISION => SqlType::Double,
    REAL => SqlType::Single,
    MONEY => SqlType::Money,
    BOOL => SqlType::Boolean,
    BOOLEAN => SqlType::Boolean,

    DATE => SqlType::Date,
    TIMESTAMP => SqlType::DateTime,
    TIMESTAMP WITHOUT TIME ZONE => SqlType::DateTime,
    TIMESTAMP WITH TIME ZONE => SqlType::DateTimeWithTimeZone,
    TIMESTAMPTZ => SqlType::DateTimeWithTimeZone,
    TIME => SqlType::Time,
    TIME WITHOUT TIME ZONE => SqlType::Time,
    TIME WITH TIME ZONE => SqlType::TimeWithTimeZone,
    TIMETZ => SqlType::TimeWithTimeZone,
    
    UUID => SqlType::Uuid,
};

qualifier_list: Vec<Qualifier> = {
    <v:qualifier_list> <q:qualifier> => {
        let mut v = v;
        v.push(q);
        v
    },
    <qualifier> => vec!(<>),
};

qualifier: Qualifier = {
    NULL => Qualifier::Null,
    NOT NULL => Qualifier::NotNull,
    UNIQUE => Qualifier::Unique,
    PRIMARY KEY => Qualifier::PrimaryKey,
};