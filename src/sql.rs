use ast::{SqlType,Statement};
use lexer::{self};
extern crate lalrpop_util as __lalrpop_util;

mod __parse__statement_list {
    #![allow(non_snake_case, non_camel_case_types, unused_mut, unused_variables, unused_imports)]

    use ast::{SqlType,Statement};
    use lexer::{self};
    extern crate lalrpop_util as __lalrpop_util;
    use super::__ToTriple;
    #[allow(dead_code)]
    pub enum __Symbol<> {
        Term_22_28_22(lexer::Token),
        Term_22_29_22(lexer::Token),
        Term_22_2c_22(lexer::Token),
        Term_22_2e_22(lexer::Token),
        Term_22_3b_22(lexer::Token),
        Term_22_3d_22(lexer::Token),
        TermBIGINT(lexer::Token),
        TermBIGSERIAL(lexer::Token),
        TermBIT(lexer::Token),
        TermBOOL(lexer::Token),
        TermBOOLEAN(lexer::Token),
        TermCHAR(lexer::Token),
        TermCHARACTER(lexer::Token),
        TermCONSTRAINT(lexer::Token),
        TermCREATE(lexer::Token),
        TermDATE(lexer::Token),
        TermDOUBLE(lexer::Token),
        TermDigit(i32),
        TermFILLFACTOR(lexer::Token),
        TermFOREIGN(lexer::Token),
        TermINT(lexer::Token),
        TermINT2(lexer::Token),
        TermINT4(lexer::Token),
        TermINT8(lexer::Token),
        TermINTEGER(lexer::Token),
        TermIdent(String),
        TermKEY(lexer::Token),
        TermMONEY(lexer::Token),
        TermNOT(lexer::Token),
        TermNULL(lexer::Token),
        TermNUMERIC(lexer::Token),
        TermPRECISION(lexer::Token),
        TermPRIMARY(lexer::Token),
        TermREAL(lexer::Token),
        TermREFERENCES(lexer::Token),
        TermSERIAL(lexer::Token),
        TermSERIAL2(lexer::Token),
        TermSERIAL4(lexer::Token),
        TermSERIAL8(lexer::Token),
        TermSMALLINT(lexer::Token),
        TermSMALLSERIAL(lexer::Token),
        TermTABLE(lexer::Token),
        TermTEXT(lexer::Token),
        TermTIME(lexer::Token),
        TermTIMESTAMP(lexer::Token),
        TermTIMESTAMPTZ(lexer::Token),
        TermTIMETZ(lexer::Token),
        TermUNIQUE(lexer::Token),
        TermUUID(lexer::Token),
        TermVARBIT(lexer::Token),
        TermVARCHAR(lexer::Token),
        TermVARYING(lexer::Token),
        TermWITH(lexer::Token),
        TermWITHOUT(lexer::Token),
        TermZONE(lexer::Token),
        Termerror(__lalrpop_util::ErrorRecovery<(), lexer::Token, ()>),
        Nt_22_3b_22_3f(::std::option::Option<lexer::Token>),
        Nt_28_22_2c_22_20constraint__list_29((lexer::Token, ())),
        Nt_28_22_2c_22_20constraint__list_29_3f(::std::option::Option<(lexer::Token, ())>),
        Nt_28Ident_20_22_2e_22_29((String, lexer::Token)),
        Nt_28Ident_20_22_2e_22_29_3f(::std::option::Option<(String, lexer::Token)>),
        Nt____statement__list(Vec<Statement>),
        Ntcolumn__definition(()),
        Ntcolumn__definition__list(()),
        Ntconstraint(()),
        Ntconstraint__list(()),
        Ntqualifier(()),
        Ntqualifier__list(()),
        Ntsql__type(SqlType),
        Ntstatement(Statement),
        Ntstatement__list(Vec<Statement>),
        Nttable__name(()),
        Ntwith__option(()),
        Ntwith__option__list(()),
        Ntwith__qualifier(()),
        Ntwith__qualifier_3f(::std::option::Option<()>),
    }
    const __ACTION: &'static [i32] = &[
        // State 0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 1
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -66, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 2
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 3
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 4
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -65, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 5
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 6
        9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 7
        -68, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 8
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 9
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 10
        0, -12, -12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 11
        0, 15, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 12
        0, 0, 0, 0, 0, 0, 18, 19, 20, 21, 22, 23, 24, 0, 0, 25, 26, 0, 0, 0, 27, 28, 29, 30, 31, 0, 0, 32, 0, 0, 33, 0, 0, 34, 0, 35, 36, 37, 38, 39, 40, 0, 41, 42, 43, 44, 45, 0, 46, 47, 48, 0, 0, 0, 0, 0,
        // State 13
        -67, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 14
        0, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, -64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 15
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 16
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 57, 0, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 17
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -35, -35, 0, 0, -35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -35, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 18
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -41, -41, 0, 0, -41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -41, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 19
        60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 61, 0, 0, 0, 0,
        // State 20
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -49, -49, 0, 0, -49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -49, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 21
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -50, -50, 0, 0, -50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -50, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 22
        62, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 23
        63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0,
        // State 24
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -51, -51, 0, 0, -51, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -51, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 25
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 26
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -33, -33, 0, 0, -33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -33, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 27
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -36, -36, 0, 0, -36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -36, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 28
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -37, -37, 0, 0, -37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -37, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 29
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -38, -38, 0, 0, -38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -38, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 30
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -34, -34, 0, 0, -34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -34, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 31
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -48, -48, 0, 0, -48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -48, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 32
        66, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 33
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -47, -47, 0, 0, -47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -47, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 34
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -40, -40, 0, 0, -40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -40, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 35
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -42, -42, 0, 0, -42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -42, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 36
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -43, -43, 0, 0, -43, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -43, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 37
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -44, -44, 0, 0, -44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -44, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 38
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -32, -32, 0, 0, -32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -32, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 39
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -39, -39, 0, 0, -39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -39, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 40
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -28, -28, 0, 0, -28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -28, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 41
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -56, -56, 0, 0, -56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -56, 0, 0, 0, 0, 67, 68, 0, 0,
        // State 42
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -52, -52, 0, 0, -52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -52, 0, 0, 0, 0, 69, 70, 0, 0,
        // State 43
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -55, -55, 0, 0, -55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -55, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 44
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -59, -59, 0, 0, -59, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -59, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 45
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -60, -60, 0, 0, -60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -60, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 46
        71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 47
        72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 48
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -62, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 49
        0, -11, -11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 50
        0, -17, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 51
        0, 73, 74, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 52
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 53
        0, -23, -23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -23, -23, 0, 0, -23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -23, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 54
        0, -10, -10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 57, 0, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 55
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 77, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 56
        0, -18, -18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -18, -18, 0, 0, -18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -18, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 57
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 58
        0, -20, -20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -20, -20, 0, 0, -20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -20, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 59
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 60
        80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 61
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 81, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 62
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 63
        83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 64
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -46, -46, 0, 0, -46, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -46, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 65
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 84, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 66
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 85, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 67
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 68
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 69
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 88, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 70
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 89, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 71
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 72
        0, 0, 0, 0, 91, 0, 0, 0, 0, 0, 0, 0, 0, 0, -63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 73
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 74
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 93, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 94, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 75
        0, -22, -22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -22, -22, 0, 0, -22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -22, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 76
        0, -19, -19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -19, -19, 0, 0, -19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -19, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 77
        0, -21, -21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -21, -21, 0, 0, -21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -21, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 78
        0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 79
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 80
        0, 97, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 81
        0, 98, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 82
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 83
        0, 0, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 84
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 101, 0,
        // State 85
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 102, 0,
        // State 86
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 103, 0,
        // State 87
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 104, 0,
        // State 88
        0, 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 89
        0, 106, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 90
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -61, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 91
        0, -16, -16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 92
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 107, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 93
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 108, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 94
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -29, -29, 0, 0, -29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -29, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 95
        0, 109, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 96
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -24, -24, 0, 0, -24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -24, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 97
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -25, -25, 0, 0, -25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -25, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 98
        0, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 99
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 100
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -58, -58, 0, 0, -58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -58, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 101
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -57, -57, 0, 0, -57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -57, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 102
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -54, -54, 0, 0, -54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -54, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 103
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -53, -53, 0, 0, -53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -53, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 104
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -30, -30, 0, 0, -30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -30, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 105
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -26, -26, 0, 0, -26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -26, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 106
        112, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 107
        113, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 108
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -31, -31, 0, 0, -31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -31, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 109
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -27, -27, 0, 0, -27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -27, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 110
        0, 114, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 111
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 112
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 113
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -45, -45, 0, 0, -45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -45, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 114
        0, 117, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 115
        0, 118, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 116
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 117
        0, -14, -14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 121, 0, 0, 0,
        // State 118
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 119
        0, -13, -13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 120
        123, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 121
        124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 122
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 123
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 124
        0, -71, -71, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 125
        0, 129, 130, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 126
        0, 0, 0, 0, 0, 131, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 127
        0, 132, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 128
        0, -72, -72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 129
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 130
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 134, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 131
        0, -15, -15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 132
        0, -70, -70, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 133
        0, -69, -69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    const __EOF_ACTION: &'static [i32] = &[
        0,
        -66,
        -9,
        0,
        -65,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -64,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -62,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -63,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -61,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    const __GOTO: &'static [i32] = &[
        // State 0
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0, 0, 0, 0,
        // State 1
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 2
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0,
        // State 3
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 4
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 5
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0,
        // State 6
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 7
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 8
        0, 0, 0, 0, 0, 0, 11, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 9
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 10
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 11
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 12
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0,
        // State 13
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 14
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 15
        0, 0, 0, 0, 0, 0, 50, 0, 51, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 16
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 54, 55, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 17
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 18
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 19
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 20
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 21
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 22
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 23
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 24
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 25
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 26
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 27
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 28
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 29
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 30
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 31
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 32
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 33
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 34
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 35
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 36
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 37
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 38
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 39
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 40
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 41
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 42
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 43
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 44
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 45
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 46
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 47
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 48
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 49
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 50
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 51
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 52
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 53
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 54
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 76, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 55
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 56
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 57
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 58
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 59
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 60
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 61
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 62
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 63
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 64
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 65
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 66
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 67
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 68
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 69
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 70
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 71
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 72
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 73
        0, 0, 0, 0, 0, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 74
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 75
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 76
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 77
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 78
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 79
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 80
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 81
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 82
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 83
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 84
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 85
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 86
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 87
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 88
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 89
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 90
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 91
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 92
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 93
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 94
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 95
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 96
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 97
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 98
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 99
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 100
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 101
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 102
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 103
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 104
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 105
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 106
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 107
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 108
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 109
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 110
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 111
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 112
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 113
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 114
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 115
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 116
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 117
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 120, 0,
        // State 118
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 122, 0, 0, 0, 0,
        // State 119
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 120
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 121
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 122
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 125, 126, 0, 0,
        // State 123
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 124
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 125
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 126
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 127
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 128
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 129
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133, 0, 0, 0,
        // State 130
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 131
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 132
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // State 133
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    fn __expected_tokens(__state: usize) -> Vec<::std::string::String> {
        const __TERMINAL: &'static [&'static str] = &[
            r###""(""###,
            r###"")""###,
            r###"",""###,
            r###"".""###,
            r###"";""###,
            r###""=""###,
            r###"BIGINT"###,
            r###"BIGSERIAL"###,
            r###"BIT"###,
            r###"BOOL"###,
            r###"BOOLEAN"###,
            r###"CHAR"###,
            r###"CHARACTER"###,
            r###"CONSTRAINT"###,
            r###"CREATE"###,
            r###"DATE"###,
            r###"DOUBLE"###,
            r###"Digit"###,
            r###"FILLFACTOR"###,
            r###"FOREIGN"###,
            r###"INT"###,
            r###"INT2"###,
            r###"INT4"###,
            r###"INT8"###,
            r###"INTEGER"###,
            r###"Ident"###,
            r###"KEY"###,
            r###"MONEY"###,
            r###"NOT"###,
            r###"NULL"###,
            r###"NUMERIC"###,
            r###"PRECISION"###,
            r###"PRIMARY"###,
            r###"REAL"###,
            r###"REFERENCES"###,
            r###"SERIAL"###,
            r###"SERIAL2"###,
            r###"SERIAL4"###,
            r###"SERIAL8"###,
            r###"SMALLINT"###,
            r###"SMALLSERIAL"###,
            r###"TABLE"###,
            r###"TEXT"###,
            r###"TIME"###,
            r###"TIMESTAMP"###,
            r###"TIMESTAMPTZ"###,
            r###"TIMETZ"###,
            r###"UNIQUE"###,
            r###"UUID"###,
            r###"VARBIT"###,
            r###"VARCHAR"###,
            r###"VARYING"###,
            r###"WITH"###,
            r###"WITHOUT"###,
            r###"ZONE"###,
        ];
        __ACTION[(__state * 56)..].iter().zip(__TERMINAL).filter_map(|(&state, terminal)| {
            if state == 0 {
                None
            } else {
                Some(terminal.to_string())
            }
        }).collect()
    }
    pub fn parse_statement_list<
        'input,
        __TOKEN: __ToTriple<'input, Error=()>,
        __TOKENS: IntoIterator<Item=__TOKEN>,
    >(
        __tokens0: __TOKENS,
    ) -> Result<Vec<Statement>, __lalrpop_util::ParseError<(), lexer::Token, ()>>
    {
        let __tokens = __tokens0.into_iter();
        let mut __tokens = __tokens.map(|t| __ToTriple::to_triple(t));
        let mut __states = vec![0_i32];
        let mut __symbols = vec![];
        let mut __integer;
        let mut __lookahead;
        let mut __last_location = Default::default();
        '__shift: loop {
            __lookahead = match __tokens.next() {
                Some(Ok(v)) => v,
                None => break '__shift,
                Some(Err(e)) => return Err(__lalrpop_util::ParseError::User { error: e }),
            };
            __last_location = __lookahead.2.clone();
            __integer = match __lookahead.1 {
                lexer::Token::LeftBracket if true => 0,
                lexer::Token::RightBracket if true => 1,
                lexer::Token::Comma if true => 2,
                lexer::Token::Period if true => 3,
                lexer::Token::Semicolon if true => 4,
                lexer::Token::Equals if true => 5,
                lexer::Token::BIGINT if true => 6,
                lexer::Token::BIGSERIAL if true => 7,
                lexer::Token::BIT if true => 8,
                lexer::Token::BOOL if true => 9,
                lexer::Token::BOOLEAN if true => 10,
                lexer::Token::CHAR if true => 11,
                lexer::Token::CHARACTER if true => 12,
                lexer::Token::CONSTRAINT if true => 13,
                lexer::Token::CREATE if true => 14,
                lexer::Token::DATE if true => 15,
                lexer::Token::DOUBLE if true => 16,
                lexer::Token::Digit(_) if true => 17,
                lexer::Token::FILLFACTOR if true => 18,
                lexer::Token::FOREIGN if true => 19,
                lexer::Token::INT if true => 20,
                lexer::Token::INT2 if true => 21,
                lexer::Token::INT4 if true => 22,
                lexer::Token::INT8 if true => 23,
                lexer::Token::INTEGER if true => 24,
                lexer::Token::Identifier(_) if true => 25,
                lexer::Token::KEY if true => 26,
                lexer::Token::MONEY if true => 27,
                lexer::Token::NOT if true => 28,
                lexer::Token::NULL if true => 29,
                lexer::Token::NUMERIC if true => 30,
                lexer::Token::PRECISION if true => 31,
                lexer::Token::PRIMARY if true => 32,
                lexer::Token::REAL if true => 33,
                lexer::Token::REFERENCES if true => 34,
                lexer::Token::SERIAL if true => 35,
                lexer::Token::SERIAL2 if true => 36,
                lexer::Token::SERIAL4 if true => 37,
                lexer::Token::SERIAL8 if true => 38,
                lexer::Token::SMALLINT if true => 39,
                lexer::Token::SMALLSERIAL if true => 40,
                lexer::Token::TABLE if true => 41,
                lexer::Token::TEXT if true => 42,
                lexer::Token::TIME if true => 43,
                lexer::Token::TIMESTAMP if true => 44,
                lexer::Token::TIMESTAMPTZ if true => 45,
                lexer::Token::TIMETZ if true => 46,
                lexer::Token::UNIQUE if true => 47,
                lexer::Token::UUID if true => 48,
                lexer::Token::VARBIT if true => 49,
                lexer::Token::VARCHAR if true => 50,
                lexer::Token::VARYING if true => 51,
                lexer::Token::WITH if true => 52,
                lexer::Token::WITHOUT if true => 53,
                lexer::Token::ZONE if true => 54,
                _ => {
                    let __state = *__states.last().unwrap() as usize;
                    let __error = __lalrpop_util::ParseError::UnrecognizedToken {
                        token: Some(__lookahead),
                        expected: __expected_tokens(__state),
                    };
                    return Err(__error);
                }
            };
            '__inner: loop {
                let __state = *__states.last().unwrap() as usize;
                let __action = __ACTION[__state * 56 + __integer];
                if __action > 0 {
                    let __symbol = match __integer {
                        0 => match __lookahead.1 {
                            __tok @ lexer::Token::LeftBracket => __Symbol::Term_22_28_22(__tok),
                            _ => unreachable!(),
                        },
                        1 => match __lookahead.1 {
                            __tok @ lexer::Token::RightBracket => __Symbol::Term_22_29_22(__tok),
                            _ => unreachable!(),
                        },
                        2 => match __lookahead.1 {
                            __tok @ lexer::Token::Comma => __Symbol::Term_22_2c_22(__tok),
                            _ => unreachable!(),
                        },
                        3 => match __lookahead.1 {
                            __tok @ lexer::Token::Period => __Symbol::Term_22_2e_22(__tok),
                            _ => unreachable!(),
                        },
                        4 => match __lookahead.1 {
                            __tok @ lexer::Token::Semicolon => __Symbol::Term_22_3b_22(__tok),
                            _ => unreachable!(),
                        },
                        5 => match __lookahead.1 {
                            __tok @ lexer::Token::Equals => __Symbol::Term_22_3d_22(__tok),
                            _ => unreachable!(),
                        },
                        6 => match __lookahead.1 {
                            __tok @ lexer::Token::BIGINT => __Symbol::TermBIGINT(__tok),
                            _ => unreachable!(),
                        },
                        7 => match __lookahead.1 {
                            __tok @ lexer::Token::BIGSERIAL => __Symbol::TermBIGSERIAL(__tok),
                            _ => unreachable!(),
                        },
                        8 => match __lookahead.1 {
                            __tok @ lexer::Token::BIT => __Symbol::TermBIT(__tok),
                            _ => unreachable!(),
                        },
                        9 => match __lookahead.1 {
                            __tok @ lexer::Token::BOOL => __Symbol::TermBOOL(__tok),
                            _ => unreachable!(),
                        },
                        10 => match __lookahead.1 {
                            __tok @ lexer::Token::BOOLEAN => __Symbol::TermBOOLEAN(__tok),
                            _ => unreachable!(),
                        },
                        11 => match __lookahead.1 {
                            __tok @ lexer::Token::CHAR => __Symbol::TermCHAR(__tok),
                            _ => unreachable!(),
                        },
                        12 => match __lookahead.1 {
                            __tok @ lexer::Token::CHARACTER => __Symbol::TermCHARACTER(__tok),
                            _ => unreachable!(),
                        },
                        13 => match __lookahead.1 {
                            __tok @ lexer::Token::CONSTRAINT => __Symbol::TermCONSTRAINT(__tok),
                            _ => unreachable!(),
                        },
                        14 => match __lookahead.1 {
                            __tok @ lexer::Token::CREATE => __Symbol::TermCREATE(__tok),
                            _ => unreachable!(),
                        },
                        15 => match __lookahead.1 {
                            __tok @ lexer::Token::DATE => __Symbol::TermDATE(__tok),
                            _ => unreachable!(),
                        },
                        16 => match __lookahead.1 {
                            __tok @ lexer::Token::DOUBLE => __Symbol::TermDOUBLE(__tok),
                            _ => unreachable!(),
                        },
                        17 => match __lookahead.1 {
                            lexer::Token::Digit(__tok0) => __Symbol::TermDigit(__tok0),
                            _ => unreachable!(),
                        },
                        18 => match __lookahead.1 {
                            __tok @ lexer::Token::FILLFACTOR => __Symbol::TermFILLFACTOR(__tok),
                            _ => unreachable!(),
                        },
                        19 => match __lookahead.1 {
                            __tok @ lexer::Token::FOREIGN => __Symbol::TermFOREIGN(__tok),
                            _ => unreachable!(),
                        },
                        20 => match __lookahead.1 {
                            __tok @ lexer::Token::INT => __Symbol::TermINT(__tok),
                            _ => unreachable!(),
                        },
                        21 => match __lookahead.1 {
                            __tok @ lexer::Token::INT2 => __Symbol::TermINT2(__tok),
                            _ => unreachable!(),
                        },
                        22 => match __lookahead.1 {
                            __tok @ lexer::Token::INT4 => __Symbol::TermINT4(__tok),
                            _ => unreachable!(),
                        },
                        23 => match __lookahead.1 {
                            __tok @ lexer::Token::INT8 => __Symbol::TermINT8(__tok),
                            _ => unreachable!(),
                        },
                        24 => match __lookahead.1 {
                            __tok @ lexer::Token::INTEGER => __Symbol::TermINTEGER(__tok),
                            _ => unreachable!(),
                        },
                        25 => match __lookahead.1 {
                            lexer::Token::Identifier(__tok0) => __Symbol::TermIdent(__tok0),
                            _ => unreachable!(),
                        },
                        26 => match __lookahead.1 {
                            __tok @ lexer::Token::KEY => __Symbol::TermKEY(__tok),
                            _ => unreachable!(),
                        },
                        27 => match __lookahead.1 {
                            __tok @ lexer::Token::MONEY => __Symbol::TermMONEY(__tok),
                            _ => unreachable!(),
                        },
                        28 => match __lookahead.1 {
                            __tok @ lexer::Token::NOT => __Symbol::TermNOT(__tok),
                            _ => unreachable!(),
                        },
                        29 => match __lookahead.1 {
                            __tok @ lexer::Token::NULL => __Symbol::TermNULL(__tok),
                            _ => unreachable!(),
                        },
                        30 => match __lookahead.1 {
                            __tok @ lexer::Token::NUMERIC => __Symbol::TermNUMERIC(__tok),
                            _ => unreachable!(),
                        },
                        31 => match __lookahead.1 {
                            __tok @ lexer::Token::PRECISION => __Symbol::TermPRECISION(__tok),
                            _ => unreachable!(),
                        },
                        32 => match __lookahead.1 {
                            __tok @ lexer::Token::PRIMARY => __Symbol::TermPRIMARY(__tok),
                            _ => unreachable!(),
                        },
                        33 => match __lookahead.1 {
                            __tok @ lexer::Token::REAL => __Symbol::TermREAL(__tok),
                            _ => unreachable!(),
                        },
                        34 => match __lookahead.1 {
                            __tok @ lexer::Token::REFERENCES => __Symbol::TermREFERENCES(__tok),
                            _ => unreachable!(),
                        },
                        35 => match __lookahead.1 {
                            __tok @ lexer::Token::SERIAL => __Symbol::TermSERIAL(__tok),
                            _ => unreachable!(),
                        },
                        36 => match __lookahead.1 {
                            __tok @ lexer::Token::SERIAL2 => __Symbol::TermSERIAL2(__tok),
                            _ => unreachable!(),
                        },
                        37 => match __lookahead.1 {
                            __tok @ lexer::Token::SERIAL4 => __Symbol::TermSERIAL4(__tok),
                            _ => unreachable!(),
                        },
                        38 => match __lookahead.1 {
                            __tok @ lexer::Token::SERIAL8 => __Symbol::TermSERIAL8(__tok),
                            _ => unreachable!(),
                        },
                        39 => match __lookahead.1 {
                            __tok @ lexer::Token::SMALLINT => __Symbol::TermSMALLINT(__tok),
                            _ => unreachable!(),
                        },
                        40 => match __lookahead.1 {
                            __tok @ lexer::Token::SMALLSERIAL => __Symbol::TermSMALLSERIAL(__tok),
                            _ => unreachable!(),
                        },
                        41 => match __lookahead.1 {
                            __tok @ lexer::Token::TABLE => __Symbol::TermTABLE(__tok),
                            _ => unreachable!(),
                        },
                        42 => match __lookahead.1 {
                            __tok @ lexer::Token::TEXT => __Symbol::TermTEXT(__tok),
                            _ => unreachable!(),
                        },
                        43 => match __lookahead.1 {
                            __tok @ lexer::Token::TIME => __Symbol::TermTIME(__tok),
                            _ => unreachable!(),
                        },
                        44 => match __lookahead.1 {
                            __tok @ lexer::Token::TIMESTAMP => __Symbol::TermTIMESTAMP(__tok),
                            _ => unreachable!(),
                        },
                        45 => match __lookahead.1 {
                            __tok @ lexer::Token::TIMESTAMPTZ => __Symbol::TermTIMESTAMPTZ(__tok),
                            _ => unreachable!(),
                        },
                        46 => match __lookahead.1 {
                            __tok @ lexer::Token::TIMETZ => __Symbol::TermTIMETZ(__tok),
                            _ => unreachable!(),
                        },
                        47 => match __lookahead.1 {
                            __tok @ lexer::Token::UNIQUE => __Symbol::TermUNIQUE(__tok),
                            _ => unreachable!(),
                        },
                        48 => match __lookahead.1 {
                            __tok @ lexer::Token::UUID => __Symbol::TermUUID(__tok),
                            _ => unreachable!(),
                        },
                        49 => match __lookahead.1 {
                            __tok @ lexer::Token::VARBIT => __Symbol::TermVARBIT(__tok),
                            _ => unreachable!(),
                        },
                        50 => match __lookahead.1 {
                            __tok @ lexer::Token::VARCHAR => __Symbol::TermVARCHAR(__tok),
                            _ => unreachable!(),
                        },
                        51 => match __lookahead.1 {
                            __tok @ lexer::Token::VARYING => __Symbol::TermVARYING(__tok),
                            _ => unreachable!(),
                        },
                        52 => match __lookahead.1 {
                            __tok @ lexer::Token::WITH => __Symbol::TermWITH(__tok),
                            _ => unreachable!(),
                        },
                        53 => match __lookahead.1 {
                            __tok @ lexer::Token::WITHOUT => __Symbol::TermWITHOUT(__tok),
                            _ => unreachable!(),
                        },
                        54 => match __lookahead.1 {
                            __tok @ lexer::Token::ZONE => __Symbol::TermZONE(__tok),
                            _ => unreachable!(),
                        },
                        _ => unreachable!(),
                    };
                    __states.push(__action - 1);
                    __symbols.push((__lookahead.0, __symbol, __lookahead.2));
                    continue '__shift;
                } else if __action < 0 {
                    if let Some(r) = __reduce(__action, Some(&__lookahead.0), &mut __states, &mut __symbols, ::std::marker::PhantomData::<()>) {
                        return r;
                    }
                } else {
                    let __state = *__states.last().unwrap() as usize;
                    let __error = __lalrpop_util::ParseError::UnrecognizedToken {
                        token: Some(__lookahead),
                        expected: __expected_tokens(__state),
                    };
                    return Err(__error)
                }
            }
        }
        loop {
            let __state = *__states.last().unwrap() as usize;
            let __action = __EOF_ACTION[__state];
            if __action < 0 {
                if let Some(r) = __reduce(__action, None, &mut __states, &mut __symbols, ::std::marker::PhantomData::<()>) {
                    return r;
                }
            } else {
                let __state = *__states.last().unwrap() as usize;
                let __error = __lalrpop_util::ParseError::UnrecognizedToken {
                    token: None,
                    expected: __expected_tokens(__state),
                };
                return Err(__error);
            }
        }
    }
    pub fn __reduce<
        'input,
    >(
        __action: i32,
        __lookahead_start: Option<&()>,
        __states: &mut ::std::vec::Vec<i32>,
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>,
        _: ::std::marker::PhantomData<()>,
    ) -> Option<Result<Vec<Statement>,__lalrpop_util::ParseError<(), lexer::Token, ()>>>
    {
        let __nonterminal = match -__action {
            1 => {
                // ";"? = ";" => ActionFn(64);
                let __sym0 = __pop_Term_22_3b_22(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action64::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Nt_22_3b_22_3f(__nt), __end));
                0
            }
            2 => {
                // ";"? =  => ActionFn(65);
                let __start = __symbols.last().map(|s| s.2.clone()).unwrap_or_default();
                let __end = __lookahead_start.cloned().unwrap_or_else(|| __start.clone());
                let __nt = super::__action65::<>(&__start, &__end);
                let __states_len = __states.len();
                __states.truncate(__states_len - 0);
                __symbols.push((__start, __Symbol::Nt_22_3b_22_3f(__nt), __end));
                0
            }
            3 => {
                // ("," constraint_list) = ",", constraint_list => ActionFn(68);
                let __sym1 = __pop_Ntconstraint__list(__symbols);
                let __sym0 = __pop_Term_22_2c_22(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action68::<>(__sym0, __sym1);
                let __states_len = __states.len();
                __states.truncate(__states_len - 2);
                __symbols.push((__start, __Symbol::Nt_28_22_2c_22_20constraint__list_29(__nt), __end));
                1
            }
            4 => {
                // ("," constraint_list)? = ",", constraint_list => ActionFn(71);
                let __sym1 = __pop_Ntconstraint__list(__symbols);
                let __sym0 = __pop_Term_22_2c_22(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action71::<>(__sym0, __sym1);
                let __states_len = __states.len();
                __states.truncate(__states_len - 2);
                __symbols.push((__start, __Symbol::Nt_28_22_2c_22_20constraint__list_29_3f(__nt), __end));
                2
            }
            5 => {
                // ("," constraint_list)? =  => ActionFn(67);
                let __start = __symbols.last().map(|s| s.2.clone()).unwrap_or_default();
                let __end = __lookahead_start.cloned().unwrap_or_else(|| __start.clone());
                let __nt = super::__action67::<>(&__start, &__end);
                let __states_len = __states.len();
                __states.truncate(__states_len - 0);
                __symbols.push((__start, __Symbol::Nt_28_22_2c_22_20constraint__list_29_3f(__nt), __end));
                2
            }
            6 => {
                // (Ident ".") = Ident, "." => ActionFn(63);
                let __sym1 = __pop_Term_22_2e_22(__symbols);
                let __sym0 = __pop_TermIdent(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action63::<>(__sym0, __sym1);
                let __states_len = __states.len();
                __states.truncate(__states_len - 2);
                __symbols.push((__start, __Symbol::Nt_28Ident_20_22_2e_22_29(__nt), __end));
                3
            }
            7 => {
                // (Ident ".")? = Ident, "." => ActionFn(76);
                let __sym1 = __pop_Term_22_2e_22(__symbols);
                let __sym0 = __pop_TermIdent(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action76::<>(__sym0, __sym1);
                let __states_len = __states.len();
                __states.truncate(__states_len - 2);
                __symbols.push((__start, __Symbol::Nt_28Ident_20_22_2e_22_29_3f(__nt), __end));
                4
            }
            8 => {
                // (Ident ".")? =  => ActionFn(62);
                let __start = __symbols.last().map(|s| s.2.clone()).unwrap_or_default();
                let __end = __lookahead_start.cloned().unwrap_or_else(|| __start.clone());
                let __nt = super::__action62::<>(&__start, &__end);
                let __states_len = __states.len();
                __states.truncate(__states_len - 0);
                __symbols.push((__start, __Symbol::Nt_28Ident_20_22_2e_22_29_3f(__nt), __end));
                4
            }
            9 => {
                // __statement_list = statement_list => ActionFn(0);
                let __sym0 = __pop_Ntstatement__list(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action0::<>(__sym0);
                return Some(Ok(__nt));
            }
            10 => {
                // column_definition = Ident, sql_type, qualifier_list => ActionFn(7);
                let __sym2 = __pop_Ntqualifier__list(__symbols);
                let __sym1 = __pop_Ntsql__type(__symbols);
                let __sym0 = __pop_TermIdent(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym2.2.clone();
                let __nt = super::__action7::<>(__sym0, __sym1, __sym2);
                let __states_len = __states.len();
                __states.truncate(__states_len - 3);
                __symbols.push((__start, __Symbol::Ntcolumn__definition(__nt), __end));
                6
            }
            11 => {
                // column_definition_list = column_definition_list, ",", column_definition => ActionFn(5);
                let __sym2 = __pop_Ntcolumn__definition(__symbols);
                let __sym1 = __pop_Term_22_2c_22(__symbols);
                let __sym0 = __pop_Ntcolumn__definition__list(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym2.2.clone();
                let __nt = super::__action5::<>(__sym0, __sym1, __sym2);
                let __states_len = __states.len();
                __states.truncate(__states_len - 3);
                __symbols.push((__start, __Symbol::Ntcolumn__definition__list(__nt), __end));
                7
            }
            12 => {
                // column_definition_list = column_definition => ActionFn(6);
                let __sym0 = __pop_Ntcolumn__definition(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action6::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntcolumn__definition__list(__nt), __end));
                7
            }
            13 => {
                // constraint = CONSTRAINT, Ident, PRIMARY, KEY, "(", Ident, ")", with_qualifier => ActionFn(79);
                let __sym7 = __pop_Ntwith__qualifier(__symbols);
                let __sym6 = __pop_Term_22_29_22(__symbols);
                let __sym5 = __pop_TermIdent(__symbols);
                let __sym4 = __pop_Term_22_28_22(__symbols);
                let __sym3 = __pop_TermKEY(__symbols);
                let __sym2 = __pop_TermPRIMARY(__symbols);
                let __sym1 = __pop_TermIdent(__symbols);
                let __sym0 = __pop_TermCONSTRAINT(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym7.2.clone();
                let __nt = super::__action79::<>(__sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                let __states_len = __states.len();
                __states.truncate(__states_len - 8);
                __symbols.push((__start, __Symbol::Ntconstraint(__nt), __end));
                8
            }
            14 => {
                // constraint = CONSTRAINT, Ident, PRIMARY, KEY, "(", Ident, ")" => ActionFn(80);
                let __sym6 = __pop_Term_22_29_22(__symbols);
                let __sym5 = __pop_TermIdent(__symbols);
                let __sym4 = __pop_Term_22_28_22(__symbols);
                let __sym3 = __pop_TermKEY(__symbols);
                let __sym2 = __pop_TermPRIMARY(__symbols);
                let __sym1 = __pop_TermIdent(__symbols);
                let __sym0 = __pop_TermCONSTRAINT(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym6.2.clone();
                let __nt = super::__action80::<>(__sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6);
                let __states_len = __states.len();
                __states.truncate(__states_len - 7);
                __symbols.push((__start, __Symbol::Ntconstraint(__nt), __end));
                8
            }
            15 => {
                // constraint = CONSTRAINT, Ident, FOREIGN, KEY, "(", Ident, ")", REFERENCES, table_name, "(", Ident, ")" => ActionFn(11);
                let __sym11 = __pop_Term_22_29_22(__symbols);
                let __sym10 = __pop_TermIdent(__symbols);
                let __sym9 = __pop_Term_22_28_22(__symbols);
                let __sym8 = __pop_Nttable__name(__symbols);
                let __sym7 = __pop_TermREFERENCES(__symbols);
                let __sym6 = __pop_Term_22_29_22(__symbols);
                let __sym5 = __pop_TermIdent(__symbols);
                let __sym4 = __pop_Term_22_28_22(__symbols);
                let __sym3 = __pop_TermKEY(__symbols);
                let __sym2 = __pop_TermFOREIGN(__symbols);
                let __sym1 = __pop_TermIdent(__symbols);
                let __sym0 = __pop_TermCONSTRAINT(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym11.2.clone();
                let __nt = super::__action11::<>(__sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8, __sym9, __sym10, __sym11);
                let __states_len = __states.len();
                __states.truncate(__states_len - 12);
                __symbols.push((__start, __Symbol::Ntconstraint(__nt), __end));
                8
            }
            16 => {
                // constraint_list = constraint_list, ",", constraint => ActionFn(8);
                let __sym2 = __pop_Ntconstraint(__symbols);
                let __sym1 = __pop_Term_22_2c_22(__symbols);
                let __sym0 = __pop_Ntconstraint__list(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym2.2.clone();
                let __nt = super::__action8::<>(__sym0, __sym1, __sym2);
                let __states_len = __states.len();
                __states.truncate(__states_len - 3);
                __symbols.push((__start, __Symbol::Ntconstraint__list(__nt), __end));
                9
            }
            17 => {
                // constraint_list = constraint => ActionFn(9);
                let __sym0 = __pop_Ntconstraint(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action9::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntconstraint__list(__nt), __end));
                9
            }
            18 => {
                // qualifier = NULL => ActionFn(55);
                let __sym0 = __pop_TermNULL(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action55::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntqualifier(__nt), __end));
                10
            }
            19 => {
                // qualifier = NOT, NULL => ActionFn(56);
                let __sym1 = __pop_TermNULL(__symbols);
                let __sym0 = __pop_TermNOT(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action56::<>(__sym0, __sym1);
                let __states_len = __states.len();
                __states.truncate(__states_len - 2);
                __symbols.push((__start, __Symbol::Ntqualifier(__nt), __end));
                10
            }
            20 => {
                // qualifier = UNIQUE => ActionFn(57);
                let __sym0 = __pop_TermUNIQUE(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action57::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntqualifier(__nt), __end));
                10
            }
            21 => {
                // qualifier = PRIMARY, KEY => ActionFn(58);
                let __sym1 = __pop_TermKEY(__symbols);
                let __sym0 = __pop_TermPRIMARY(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action58::<>(__sym0, __sym1);
                let __states_len = __states.len();
                __states.truncate(__states_len - 2);
                __symbols.push((__start, __Symbol::Ntqualifier(__nt), __end));
                10
            }
            22 => {
                // qualifier_list = qualifier_list, qualifier => ActionFn(53);
                let __sym1 = __pop_Ntqualifier(__symbols);
                let __sym0 = __pop_Ntqualifier__list(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action53::<>(__sym0, __sym1);
                let __states_len = __states.len();
                __states.truncate(__states_len - 2);
                __symbols.push((__start, __Symbol::Ntqualifier__list(__nt), __end));
                11
            }
            23 => {
                // qualifier_list = qualifier => ActionFn(54);
                let __sym0 = __pop_Ntqualifier(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action54::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntqualifier__list(__nt), __end));
                11
            }
            24 => {
                // sql_type = CHAR, "(", Digit, ")" => ActionFn(16);
                let __sym3 = __pop_Term_22_29_22(__symbols);
                let __sym2 = __pop_TermDigit(__symbols);
                let __sym1 = __pop_Term_22_28_22(__symbols);
                let __sym0 = __pop_TermCHAR(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym3.2.clone();
                let __nt = super::__action16::<>(__sym0, __sym1, __sym2, __sym3);
                let __states_len = __states.len();
                __states.truncate(__states_len - 4);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            25 => {
                // sql_type = CHARACTER, "(", Digit, ")" => ActionFn(17);
                let __sym3 = __pop_Term_22_29_22(__symbols);
                let __sym2 = __pop_TermDigit(__symbols);
                let __sym1 = __pop_Term_22_28_22(__symbols);
                let __sym0 = __pop_TermCHARACTER(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym3.2.clone();
                let __nt = super::__action17::<>(__sym0, __sym1, __sym2, __sym3);
                let __states_len = __states.len();
                __states.truncate(__states_len - 4);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            26 => {
                // sql_type = VARCHAR, "(", Digit, ")" => ActionFn(18);
                let __sym3 = __pop_Term_22_29_22(__symbols);
                let __sym2 = __pop_TermDigit(__symbols);
                let __sym1 = __pop_Term_22_28_22(__symbols);
                let __sym0 = __pop_TermVARCHAR(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym3.2.clone();
                let __nt = super::__action18::<>(__sym0, __sym1, __sym2, __sym3);
                let __states_len = __states.len();
                __states.truncate(__states_len - 4);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            27 => {
                // sql_type = CHARACTER, VARYING, "(", Digit, ")" => ActionFn(19);
                let __sym4 = __pop_Term_22_29_22(__symbols);
                let __sym3 = __pop_TermDigit(__symbols);
                let __sym2 = __pop_Term_22_28_22(__symbols);
                let __sym1 = __pop_TermVARYING(__symbols);
                let __sym0 = __pop_TermCHARACTER(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym4.2.clone();
                let __nt = super::__action19::<>(__sym0, __sym1, __sym2, __sym3, __sym4);
                let __states_len = __states.len();
                __states.truncate(__states_len - 5);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            28 => {
                // sql_type = TEXT => ActionFn(20);
                let __sym0 = __pop_TermTEXT(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action20::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            29 => {
                // sql_type = BIT, "(", Digit, ")" => ActionFn(21);
                let __sym3 = __pop_Term_22_29_22(__symbols);
                let __sym2 = __pop_TermDigit(__symbols);
                let __sym1 = __pop_Term_22_28_22(__symbols);
                let __sym0 = __pop_TermBIT(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym3.2.clone();
                let __nt = super::__action21::<>(__sym0, __sym1, __sym2, __sym3);
                let __states_len = __states.len();
                __states.truncate(__states_len - 4);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            30 => {
                // sql_type = VARBIT, "(", Digit, ")" => ActionFn(22);
                let __sym3 = __pop_Term_22_29_22(__symbols);
                let __sym2 = __pop_TermDigit(__symbols);
                let __sym1 = __pop_Term_22_28_22(__symbols);
                let __sym0 = __pop_TermVARBIT(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym3.2.clone();
                let __nt = super::__action22::<>(__sym0, __sym1, __sym2, __sym3);
                let __states_len = __states.len();
                __states.truncate(__states_len - 4);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            31 => {
                // sql_type = BIT, VARYING, "(", Digit, ")" => ActionFn(23);
                let __sym4 = __pop_Term_22_29_22(__symbols);
                let __sym3 = __pop_TermDigit(__symbols);
                let __sym2 = __pop_Term_22_28_22(__symbols);
                let __sym1 = __pop_TermVARYING(__symbols);
                let __sym0 = __pop_TermBIT(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym4.2.clone();
                let __nt = super::__action23::<>(__sym0, __sym1, __sym2, __sym3, __sym4);
                let __states_len = __states.len();
                __states.truncate(__states_len - 5);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            32 => {
                // sql_type = SMALLINT => ActionFn(24);
                let __sym0 = __pop_TermSMALLINT(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action24::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            33 => {
                // sql_type = INT => ActionFn(25);
                let __sym0 = __pop_TermINT(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action25::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            34 => {
                // sql_type = INTEGER => ActionFn(26);
                let __sym0 = __pop_TermINTEGER(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action26::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            35 => {
                // sql_type = BIGINT => ActionFn(27);
                let __sym0 = __pop_TermBIGINT(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action27::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            36 => {
                // sql_type = INT2 => ActionFn(28);
                let __sym0 = __pop_TermINT2(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action28::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            37 => {
                // sql_type = INT4 => ActionFn(29);
                let __sym0 = __pop_TermINT4(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action29::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            38 => {
                // sql_type = INT8 => ActionFn(30);
                let __sym0 = __pop_TermINT8(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action30::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            39 => {
                // sql_type = SMALLSERIAL => ActionFn(31);
                let __sym0 = __pop_TermSMALLSERIAL(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action31::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            40 => {
                // sql_type = SERIAL => ActionFn(32);
                let __sym0 = __pop_TermSERIAL(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action32::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            41 => {
                // sql_type = BIGSERIAL => ActionFn(33);
                let __sym0 = __pop_TermBIGSERIAL(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action33::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            42 => {
                // sql_type = SERIAL2 => ActionFn(34);
                let __sym0 = __pop_TermSERIAL2(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action34::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            43 => {
                // sql_type = SERIAL4 => ActionFn(35);
                let __sym0 = __pop_TermSERIAL4(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action35::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            44 => {
                // sql_type = SERIAL8 => ActionFn(36);
                let __sym0 = __pop_TermSERIAL8(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action36::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            45 => {
                // sql_type = NUMERIC, "(", Digit, ",", Digit, ")" => ActionFn(37);
                let __sym5 = __pop_Term_22_29_22(__symbols);
                let __sym4 = __pop_TermDigit(__symbols);
                let __sym3 = __pop_Term_22_2c_22(__symbols);
                let __sym2 = __pop_TermDigit(__symbols);
                let __sym1 = __pop_Term_22_28_22(__symbols);
                let __sym0 = __pop_TermNUMERIC(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym5.2.clone();
                let __nt = super::__action37::<>(__sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                let __states_len = __states.len();
                __states.truncate(__states_len - 6);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            46 => {
                // sql_type = DOUBLE, PRECISION => ActionFn(38);
                let __sym1 = __pop_TermPRECISION(__symbols);
                let __sym0 = __pop_TermDOUBLE(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action38::<>(__sym0, __sym1);
                let __states_len = __states.len();
                __states.truncate(__states_len - 2);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            47 => {
                // sql_type = REAL => ActionFn(39);
                let __sym0 = __pop_TermREAL(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action39::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            48 => {
                // sql_type = MONEY => ActionFn(40);
                let __sym0 = __pop_TermMONEY(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action40::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            49 => {
                // sql_type = BOOL => ActionFn(41);
                let __sym0 = __pop_TermBOOL(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action41::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            50 => {
                // sql_type = BOOLEAN => ActionFn(42);
                let __sym0 = __pop_TermBOOLEAN(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action42::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            51 => {
                // sql_type = DATE => ActionFn(43);
                let __sym0 = __pop_TermDATE(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action43::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            52 => {
                // sql_type = TIMESTAMP => ActionFn(44);
                let __sym0 = __pop_TermTIMESTAMP(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action44::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            53 => {
                // sql_type = TIMESTAMP, WITHOUT, TIME, ZONE => ActionFn(45);
                let __sym3 = __pop_TermZONE(__symbols);
                let __sym2 = __pop_TermTIME(__symbols);
                let __sym1 = __pop_TermWITHOUT(__symbols);
                let __sym0 = __pop_TermTIMESTAMP(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym3.2.clone();
                let __nt = super::__action45::<>(__sym0, __sym1, __sym2, __sym3);
                let __states_len = __states.len();
                __states.truncate(__states_len - 4);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            54 => {
                // sql_type = TIMESTAMP, WITH, TIME, ZONE => ActionFn(46);
                let __sym3 = __pop_TermZONE(__symbols);
                let __sym2 = __pop_TermTIME(__symbols);
                let __sym1 = __pop_TermWITH(__symbols);
                let __sym0 = __pop_TermTIMESTAMP(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym3.2.clone();
                let __nt = super::__action46::<>(__sym0, __sym1, __sym2, __sym3);
                let __states_len = __states.len();
                __states.truncate(__states_len - 4);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            55 => {
                // sql_type = TIMESTAMPTZ => ActionFn(47);
                let __sym0 = __pop_TermTIMESTAMPTZ(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action47::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            56 => {
                // sql_type = TIME => ActionFn(48);
                let __sym0 = __pop_TermTIME(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action48::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            57 => {
                // sql_type = TIME, WITHOUT, TIME, ZONE => ActionFn(49);
                let __sym3 = __pop_TermZONE(__symbols);
                let __sym2 = __pop_TermTIME(__symbols);
                let __sym1 = __pop_TermWITHOUT(__symbols);
                let __sym0 = __pop_TermTIME(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym3.2.clone();
                let __nt = super::__action49::<>(__sym0, __sym1, __sym2, __sym3);
                let __states_len = __states.len();
                __states.truncate(__states_len - 4);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            58 => {
                // sql_type = TIME, WITH, TIME, ZONE => ActionFn(50);
                let __sym3 = __pop_TermZONE(__symbols);
                let __sym2 = __pop_TermTIME(__symbols);
                let __sym1 = __pop_TermWITH(__symbols);
                let __sym0 = __pop_TermTIME(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym3.2.clone();
                let __nt = super::__action50::<>(__sym0, __sym1, __sym2, __sym3);
                let __states_len = __states.len();
                __states.truncate(__states_len - 4);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            59 => {
                // sql_type = TIMETZ => ActionFn(51);
                let __sym0 = __pop_TermTIMETZ(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action51::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            60 => {
                // sql_type = UUID => ActionFn(52);
                let __sym0 = __pop_TermUUID(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action52::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntsql__type(__nt), __end));
                12
            }
            61 => {
                // statement = CREATE, TABLE, table_name, "(", column_definition_list, ",", constraint_list, ")", ";" => ActionFn(72);
                let __sym8 = __pop_Term_22_3b_22(__symbols);
                let __sym7 = __pop_Term_22_29_22(__symbols);
                let __sym6 = __pop_Ntconstraint__list(__symbols);
                let __sym5 = __pop_Term_22_2c_22(__symbols);
                let __sym4 = __pop_Ntcolumn__definition__list(__symbols);
                let __sym3 = __pop_Term_22_28_22(__symbols);
                let __sym2 = __pop_Nttable__name(__symbols);
                let __sym1 = __pop_TermTABLE(__symbols);
                let __sym0 = __pop_TermCREATE(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym8.2.clone();
                let __nt = super::__action72::<>(__sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7, __sym8);
                let __states_len = __states.len();
                __states.truncate(__states_len - 9);
                __symbols.push((__start, __Symbol::Ntstatement(__nt), __end));
                13
            }
            62 => {
                // statement = CREATE, TABLE, table_name, "(", column_definition_list, ")", ";" => ActionFn(73);
                let __sym6 = __pop_Term_22_3b_22(__symbols);
                let __sym5 = __pop_Term_22_29_22(__symbols);
                let __sym4 = __pop_Ntcolumn__definition__list(__symbols);
                let __sym3 = __pop_Term_22_28_22(__symbols);
                let __sym2 = __pop_Nttable__name(__symbols);
                let __sym1 = __pop_TermTABLE(__symbols);
                let __sym0 = __pop_TermCREATE(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym6.2.clone();
                let __nt = super::__action73::<>(__sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6);
                let __states_len = __states.len();
                __states.truncate(__states_len - 7);
                __symbols.push((__start, __Symbol::Ntstatement(__nt), __end));
                13
            }
            63 => {
                // statement = CREATE, TABLE, table_name, "(", column_definition_list, ",", constraint_list, ")" => ActionFn(74);
                let __sym7 = __pop_Term_22_29_22(__symbols);
                let __sym6 = __pop_Ntconstraint__list(__symbols);
                let __sym5 = __pop_Term_22_2c_22(__symbols);
                let __sym4 = __pop_Ntcolumn__definition__list(__symbols);
                let __sym3 = __pop_Term_22_28_22(__symbols);
                let __sym2 = __pop_Nttable__name(__symbols);
                let __sym1 = __pop_TermTABLE(__symbols);
                let __sym0 = __pop_TermCREATE(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym7.2.clone();
                let __nt = super::__action74::<>(__sym0, __sym1, __sym2, __sym3, __sym4, __sym5, __sym6, __sym7);
                let __states_len = __states.len();
                __states.truncate(__states_len - 8);
                __symbols.push((__start, __Symbol::Ntstatement(__nt), __end));
                13
            }
            64 => {
                // statement = CREATE, TABLE, table_name, "(", column_definition_list, ")" => ActionFn(75);
                let __sym5 = __pop_Term_22_29_22(__symbols);
                let __sym4 = __pop_Ntcolumn__definition__list(__symbols);
                let __sym3 = __pop_Term_22_28_22(__symbols);
                let __sym2 = __pop_Nttable__name(__symbols);
                let __sym1 = __pop_TermTABLE(__symbols);
                let __sym0 = __pop_TermCREATE(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym5.2.clone();
                let __nt = super::__action75::<>(__sym0, __sym1, __sym2, __sym3, __sym4, __sym5);
                let __states_len = __states.len();
                __states.truncate(__states_len - 6);
                __symbols.push((__start, __Symbol::Ntstatement(__nt), __end));
                13
            }
            65 => {
                // statement_list = statement_list, statement => ActionFn(1);
                let __sym1 = __pop_Ntstatement(__symbols);
                let __sym0 = __pop_Ntstatement__list(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym1.2.clone();
                let __nt = super::__action1::<>(__sym0, __sym1);
                let __states_len = __states.len();
                __states.truncate(__states_len - 2);
                __symbols.push((__start, __Symbol::Ntstatement__list(__nt), __end));
                14
            }
            66 => {
                // statement_list = statement => ActionFn(2);
                let __sym0 = __pop_Ntstatement(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action2::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntstatement__list(__nt), __end));
                14
            }
            67 => {
                // table_name = Ident, ".", Ident => ActionFn(77);
                let __sym2 = __pop_TermIdent(__symbols);
                let __sym1 = __pop_Term_22_2e_22(__symbols);
                let __sym0 = __pop_TermIdent(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym2.2.clone();
                let __nt = super::__action77::<>(__sym0, __sym1, __sym2);
                let __states_len = __states.len();
                __states.truncate(__states_len - 3);
                __symbols.push((__start, __Symbol::Nttable__name(__nt), __end));
                15
            }
            68 => {
                // table_name = Ident => ActionFn(78);
                let __sym0 = __pop_TermIdent(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action78::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Nttable__name(__nt), __end));
                15
            }
            69 => {
                // with_option = FILLFACTOR, "=", Digit => ActionFn(15);
                let __sym2 = __pop_TermDigit(__symbols);
                let __sym1 = __pop_Term_22_3d_22(__symbols);
                let __sym0 = __pop_TermFILLFACTOR(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym2.2.clone();
                let __nt = super::__action15::<>(__sym0, __sym1, __sym2);
                let __states_len = __states.len();
                __states.truncate(__states_len - 3);
                __symbols.push((__start, __Symbol::Ntwith__option(__nt), __end));
                16
            }
            70 => {
                // with_option_list = with_option_list, ",", with_option => ActionFn(13);
                let __sym2 = __pop_Ntwith__option(__symbols);
                let __sym1 = __pop_Term_22_2c_22(__symbols);
                let __sym0 = __pop_Ntwith__option__list(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym2.2.clone();
                let __nt = super::__action13::<>(__sym0, __sym1, __sym2);
                let __states_len = __states.len();
                __states.truncate(__states_len - 3);
                __symbols.push((__start, __Symbol::Ntwith__option__list(__nt), __end));
                17
            }
            71 => {
                // with_option_list = with_option => ActionFn(14);
                let __sym0 = __pop_Ntwith__option(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action14::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntwith__option__list(__nt), __end));
                17
            }
            72 => {
                // with_qualifier = WITH, "(", with_option_list, ")" => ActionFn(12);
                let __sym3 = __pop_Term_22_29_22(__symbols);
                let __sym2 = __pop_Ntwith__option__list(__symbols);
                let __sym1 = __pop_Term_22_28_22(__symbols);
                let __sym0 = __pop_TermWITH(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym3.2.clone();
                let __nt = super::__action12::<>(__sym0, __sym1, __sym2, __sym3);
                let __states_len = __states.len();
                __states.truncate(__states_len - 4);
                __symbols.push((__start, __Symbol::Ntwith__qualifier(__nt), __end));
                18
            }
            73 => {
                // with_qualifier? = with_qualifier => ActionFn(59);
                let __sym0 = __pop_Ntwith__qualifier(__symbols);
                let __start = __sym0.0.clone();
                let __end = __sym0.2.clone();
                let __nt = super::__action59::<>(__sym0);
                let __states_len = __states.len();
                __states.truncate(__states_len - 1);
                __symbols.push((__start, __Symbol::Ntwith__qualifier_3f(__nt), __end));
                19
            }
            74 => {
                // with_qualifier? =  => ActionFn(60);
                let __start = __symbols.last().map(|s| s.2.clone()).unwrap_or_default();
                let __end = __lookahead_start.cloned().unwrap_or_else(|| __start.clone());
                let __nt = super::__action60::<>(&__start, &__end);
                let __states_len = __states.len();
                __states.truncate(__states_len - 0);
                __symbols.push((__start, __Symbol::Ntwith__qualifier_3f(__nt), __end));
                19
            }
            _ => panic!("invalid action code {}", __action)
        };
        let __state = *__states.last().unwrap() as usize;
        let __next_state = __GOTO[__state * 20 + __nonterminal] - 1;
        __states.push(__next_state);
        None
    }
    fn __pop_Term_22_28_22<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Term_22_28_22(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Term_22_29_22<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Term_22_29_22(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Term_22_2c_22<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Term_22_2c_22(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Term_22_2e_22<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Term_22_2e_22(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Term_22_3b_22<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Term_22_3b_22(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Term_22_3d_22<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Term_22_3d_22(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermBIGINT<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermBIGINT(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermBIGSERIAL<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermBIGSERIAL(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermBIT<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermBIT(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermBOOL<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermBOOL(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermBOOLEAN<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermBOOLEAN(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermCHAR<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermCHAR(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermCHARACTER<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermCHARACTER(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermCONSTRAINT<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermCONSTRAINT(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermCREATE<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermCREATE(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermDATE<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermDATE(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermDOUBLE<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermDOUBLE(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermDigit<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), i32, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermDigit(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermFILLFACTOR<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermFILLFACTOR(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermFOREIGN<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermFOREIGN(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermINT<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermINT(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermINT2<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermINT2(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermINT4<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermINT4(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermINT8<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermINT8(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermINTEGER<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermINTEGER(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermIdent<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), String, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermIdent(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermKEY<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermKEY(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermMONEY<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermMONEY(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermNOT<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermNOT(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermNULL<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermNULL(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermNUMERIC<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermNUMERIC(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermPRECISION<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermPRECISION(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermPRIMARY<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermPRIMARY(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermREAL<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermREAL(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermREFERENCES<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermREFERENCES(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermSERIAL<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermSERIAL(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermSERIAL2<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermSERIAL2(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermSERIAL4<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermSERIAL4(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermSERIAL8<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermSERIAL8(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermSMALLINT<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermSMALLINT(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermSMALLSERIAL<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermSMALLSERIAL(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermTABLE<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermTABLE(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermTEXT<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermTEXT(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermTIME<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermTIME(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermTIMESTAMP<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermTIMESTAMP(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermTIMESTAMPTZ<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermTIMESTAMPTZ(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermTIMETZ<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermTIMETZ(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermUNIQUE<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermUNIQUE(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermUUID<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermUUID(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermVARBIT<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermVARBIT(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermVARCHAR<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermVARCHAR(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermVARYING<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermVARYING(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermWITH<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermWITH(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermWITHOUT<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermWITHOUT(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_TermZONE<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), lexer::Token, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::TermZONE(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Termerror<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), __lalrpop_util::ErrorRecovery<(), lexer::Token, ()>, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Termerror(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Nt_22_3b_22_3f<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), ::std::option::Option<lexer::Token>, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Nt_22_3b_22_3f(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Nt_28_22_2c_22_20constraint__list_29<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), (lexer::Token, ()), ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Nt_28_22_2c_22_20constraint__list_29(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Nt_28_22_2c_22_20constraint__list_29_3f<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), ::std::option::Option<(lexer::Token, ())>, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Nt_28_22_2c_22_20constraint__list_29_3f(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Nt_28Ident_20_22_2e_22_29<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), (String, lexer::Token), ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Nt_28Ident_20_22_2e_22_29(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Nt_28Ident_20_22_2e_22_29_3f<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), ::std::option::Option<(String, lexer::Token)>, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Nt_28Ident_20_22_2e_22_29_3f(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Nt____statement__list<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), Vec<Statement>, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Nt____statement__list(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Ntcolumn__definition<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), (), ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Ntcolumn__definition(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Ntcolumn__definition__list<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), (), ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Ntcolumn__definition__list(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Ntconstraint<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), (), ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Ntconstraint(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Ntconstraint__list<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), (), ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Ntconstraint__list(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Ntqualifier<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), (), ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Ntqualifier(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Ntqualifier__list<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), (), ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Ntqualifier__list(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Ntsql__type<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), SqlType, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Ntsql__type(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Ntstatement<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), Statement, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Ntstatement(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Ntstatement__list<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), Vec<Statement>, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Ntstatement__list(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Nttable__name<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), (), ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Nttable__name(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Ntwith__option<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), (), ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Ntwith__option(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Ntwith__option__list<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), (), ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Ntwith__option__list(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Ntwith__qualifier<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), (), ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Ntwith__qualifier(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
    fn __pop_Ntwith__qualifier_3f<
    >(
        __symbols: &mut ::std::vec::Vec<((),__Symbol<>,())>
    ) -> ((), ::std::option::Option<()>, ()) {
        match __symbols.pop().unwrap() {
            (__l, __Symbol::Ntwith__qualifier_3f(__v), __r) => (__l, __v, __r),
            _ => panic!("symbol type mismatch")
        }
    }
}
pub use self::__parse__statement_list::parse_statement_list;

pub fn __action0<
    'input,
>(
    (_, __0, _): ((), Vec<Statement>, ()),
) -> Vec<Statement>
{
    (__0)
}

pub fn __action1<
    'input,
>(
    (_, v, _): ((), Vec<Statement>, ()),
    (_, stmt, _): ((), Statement, ()),
) -> Vec<Statement>
{
    {
        let mut v = v;
        v.push(stmt);
        v
    }
}

pub fn __action2<
    'input,
>(
    (_, __0, _): ((), Statement, ()),
) -> Vec<Statement>
{
    vec!(__0)
}

pub fn __action3<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
    (_, __1, _): ((), lexer::Token, ()),
    (_, __2, _): ((), (), ()),
    (_, __3, _): ((), lexer::Token, ()),
    (_, __4, _): ((), (), ()),
    (_, __5, _): ((), ::std::option::Option<(lexer::Token, ())>, ()),
    (_, __6, _): ((), lexer::Token, ()),
    (_, __7, _): ((), ::std::option::Option<lexer::Token>, ()),
) -> Statement
{
    Statement::Table
}

pub fn __action4<
    'input,
>(
    (_, __0, _): ((), ::std::option::Option<(String, lexer::Token)>, ()),
    (_, __1, _): ((), String, ()),
) -> ()
{
    ()
}

pub fn __action5<
    'input,
>(
    (_, __0, _): ((), (), ()),
    (_, __1, _): ((), lexer::Token, ()),
    (_, __2, _): ((), (), ()),
) -> ()
{
    ()
}

pub fn __action6<
    'input,
>(
    (_, __0, _): ((), (), ()),
) -> ()
{
    ()
}

pub fn __action7<
    'input,
>(
    (_, __0, _): ((), String, ()),
    (_, __1, _): ((), SqlType, ()),
    (_, __2, _): ((), (), ()),
) -> ()
{
    ()
}

pub fn __action8<
    'input,
>(
    (_, __0, _): ((), (), ()),
    (_, __1, _): ((), lexer::Token, ()),
    (_, __2, _): ((), (), ()),
) -> ()
{
    ()
}

pub fn __action9<
    'input,
>(
    (_, __0, _): ((), (), ()),
) -> ()
{
    ()
}

pub fn __action10<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
    (_, __1, _): ((), String, ()),
    (_, __2, _): ((), lexer::Token, ()),
    (_, __3, _): ((), lexer::Token, ()),
    (_, __4, _): ((), lexer::Token, ()),
    (_, __5, _): ((), String, ()),
    (_, __6, _): ((), lexer::Token, ()),
    (_, __7, _): ((), ::std::option::Option<()>, ()),
) -> ()
{
    ()
}

pub fn __action11<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
    (_, __1, _): ((), String, ()),
    (_, __2, _): ((), lexer::Token, ()),
    (_, __3, _): ((), lexer::Token, ()),
    (_, __4, _): ((), lexer::Token, ()),
    (_, __5, _): ((), String, ()),
    (_, __6, _): ((), lexer::Token, ()),
    (_, __7, _): ((), lexer::Token, ()),
    (_, __8, _): ((), (), ()),
    (_, __9, _): ((), lexer::Token, ()),
    (_, __10, _): ((), String, ()),
    (_, __11, _): ((), lexer::Token, ()),
) -> ()
{
    ()
}

pub fn __action12<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
    (_, __1, _): ((), lexer::Token, ()),
    (_, __2, _): ((), (), ()),
    (_, __3, _): ((), lexer::Token, ()),
) -> ()
{
    ()
}

pub fn __action13<
    'input,
>(
    (_, __0, _): ((), (), ()),
    (_, __1, _): ((), lexer::Token, ()),
    (_, __2, _): ((), (), ()),
) -> ()
{
    ()
}

pub fn __action14<
    'input,
>(
    (_, __0, _): ((), (), ()),
) -> ()
{
    ()
}

pub fn __action15<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
    (_, __1, _): ((), lexer::Token, ()),
    (_, __2, _): ((), i32, ()),
) -> ()
{
    ()
}

pub fn __action16<
    'input,
>(
    (_, _, _): ((), lexer::Token, ()),
    (_, _, _): ((), lexer::Token, ()),
    (_, __0, _): ((), i32, ()),
    (_, _, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::FixedLengthString(__0 as u32)
}

pub fn __action17<
    'input,
>(
    (_, _, _): ((), lexer::Token, ()),
    (_, _, _): ((), lexer::Token, ()),
    (_, __0, _): ((), i32, ()),
    (_, _, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::FixedLengthString(__0 as u32)
}

pub fn __action18<
    'input,
>(
    (_, _, _): ((), lexer::Token, ()),
    (_, _, _): ((), lexer::Token, ()),
    (_, __0, _): ((), i32, ()),
    (_, _, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::VariableLengthString(__0 as u32)
}

pub fn __action19<
    'input,
>(
    (_, _, _): ((), lexer::Token, ()),
    (_, _, _): ((), lexer::Token, ()),
    (_, _, _): ((), lexer::Token, ()),
    (_, __0, _): ((), i32, ()),
    (_, _, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::VariableLengthString(__0 as u32)
}

pub fn __action20<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::Text
}

pub fn __action21<
    'input,
>(
    (_, _, _): ((), lexer::Token, ()),
    (_, _, _): ((), lexer::Token, ()),
    (_, __0, _): ((), i32, ()),
    (_, _, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::FixedLengthBitString(__0 as u32)
}

pub fn __action22<
    'input,
>(
    (_, _, _): ((), lexer::Token, ()),
    (_, _, _): ((), lexer::Token, ()),
    (_, __0, _): ((), i32, ()),
    (_, _, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::VariableLengthBitString(__0 as u32)
}

pub fn __action23<
    'input,
>(
    (_, _, _): ((), lexer::Token, ()),
    (_, _, _): ((), lexer::Token, ()),
    (_, _, _): ((), lexer::Token, ()),
    (_, __0, _): ((), i32, ()),
    (_, _, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::VariableLengthBitString(__0 as u32)
}

pub fn __action24<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::SmallInteger
}

pub fn __action25<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::Integer
}

pub fn __action26<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::Integer
}

pub fn __action27<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::BigInteger
}

pub fn __action28<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::SmallInteger
}

pub fn __action29<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::Integer
}

pub fn __action30<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::BigInteger
}

pub fn __action31<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::SmallSerial
}

pub fn __action32<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::Serial
}

pub fn __action33<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::BigSerial
}

pub fn __action34<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::SmallSerial
}

pub fn __action35<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::Serial
}

pub fn __action36<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::BigSerial
}

pub fn __action37<
    'input,
>(
    (_, _, _): ((), lexer::Token, ()),
    (_, _, _): ((), lexer::Token, ()),
    (_, m, _): ((), i32, ()),
    (_, _, _): ((), lexer::Token, ()),
    (_, d, _): ((), i32, ()),
    (_, _, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::Numeric(m as u32, d as u32)
}

pub fn __action38<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
    (_, __1, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::Double
}

pub fn __action39<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::Single
}

pub fn __action40<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::Money
}

pub fn __action41<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::Boolean
}

pub fn __action42<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::Boolean
}

pub fn __action43<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::Date
}

pub fn __action44<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::DateTime
}

pub fn __action45<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
    (_, __1, _): ((), lexer::Token, ()),
    (_, __2, _): ((), lexer::Token, ()),
    (_, __3, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::DateTime
}

pub fn __action46<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
    (_, __1, _): ((), lexer::Token, ()),
    (_, __2, _): ((), lexer::Token, ()),
    (_, __3, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::DateTimeWithTimeZone
}

pub fn __action47<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::DateTimeWithTimeZone
}

pub fn __action48<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::Time
}

pub fn __action49<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
    (_, __1, _): ((), lexer::Token, ()),
    (_, __2, _): ((), lexer::Token, ()),
    (_, __3, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::Time
}

pub fn __action50<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
    (_, __1, _): ((), lexer::Token, ()),
    (_, __2, _): ((), lexer::Token, ()),
    (_, __3, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::TimeWithTimeZone
}

pub fn __action51<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::TimeWithTimeZone
}

pub fn __action52<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> SqlType
{
    SqlType::Uuid
}

pub fn __action53<
    'input,
>(
    (_, __0, _): ((), (), ()),
    (_, __1, _): ((), (), ()),
) -> ()
{
    ()
}

pub fn __action54<
    'input,
>(
    (_, __0, _): ((), (), ()),
) -> ()
{
    ()
}

pub fn __action55<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> ()
{
    ()
}

pub fn __action56<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
    (_, __1, _): ((), lexer::Token, ()),
) -> ()
{
    ()
}

pub fn __action57<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> ()
{
    ()
}

pub fn __action58<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
    (_, __1, _): ((), lexer::Token, ()),
) -> ()
{
    ()
}

pub fn __action59<
    'input,
>(
    (_, __0, _): ((), (), ()),
) -> ::std::option::Option<()>
{
    Some(__0)
}

pub fn __action60<
    'input,
>(
    __lookbehind: &(),
    __lookahead: &(),
) -> ::std::option::Option<()>
{
    None
}

pub fn __action61<
    'input,
>(
    (_, __0, _): ((), (String, lexer::Token), ()),
) -> ::std::option::Option<(String, lexer::Token)>
{
    Some(__0)
}

pub fn __action62<
    'input,
>(
    __lookbehind: &(),
    __lookahead: &(),
) -> ::std::option::Option<(String, lexer::Token)>
{
    None
}

pub fn __action63<
    'input,
>(
    (_, __0, _): ((), String, ()),
    (_, __1, _): ((), lexer::Token, ()),
) -> (String, lexer::Token)
{
    (__0, __1)
}

pub fn __action64<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
) -> ::std::option::Option<lexer::Token>
{
    Some(__0)
}

pub fn __action65<
    'input,
>(
    __lookbehind: &(),
    __lookahead: &(),
) -> ::std::option::Option<lexer::Token>
{
    None
}

pub fn __action66<
    'input,
>(
    (_, __0, _): ((), (lexer::Token, ()), ()),
) -> ::std::option::Option<(lexer::Token, ())>
{
    Some(__0)
}

pub fn __action67<
    'input,
>(
    __lookbehind: &(),
    __lookahead: &(),
) -> ::std::option::Option<(lexer::Token, ())>
{
    None
}

pub fn __action68<
    'input,
>(
    (_, __0, _): ((), lexer::Token, ()),
    (_, __1, _): ((), (), ()),
) -> (lexer::Token, ())
{
    (__0, __1)
}

pub fn __action69<
    'input,
>(
    __0: ((), lexer::Token, ()),
    __1: ((), lexer::Token, ()),
    __2: ((), (), ()),
    __3: ((), lexer::Token, ()),
    __4: ((), (), ()),
    __5: ((), ::std::option::Option<(lexer::Token, ())>, ()),
    __6: ((), lexer::Token, ()),
    __7: ((), lexer::Token, ()),
) -> Statement
{
    let __start0 = __7.0.clone();
    let __end0 = __7.2.clone();
    let __temp0 = __action64(
        __7,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action3(
        __0,
        __1,
        __2,
        __3,
        __4,
        __5,
        __6,
        __temp0,
    )
}

pub fn __action70<
    'input,
>(
    __0: ((), lexer::Token, ()),
    __1: ((), lexer::Token, ()),
    __2: ((), (), ()),
    __3: ((), lexer::Token, ()),
    __4: ((), (), ()),
    __5: ((), ::std::option::Option<(lexer::Token, ())>, ()),
    __6: ((), lexer::Token, ()),
) -> Statement
{
    let __start0 = __6.2.clone();
    let __end0 = __6.2.clone();
    let __temp0 = __action65(
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action3(
        __0,
        __1,
        __2,
        __3,
        __4,
        __5,
        __6,
        __temp0,
    )
}

pub fn __action71<
    'input,
>(
    __0: ((), lexer::Token, ()),
    __1: ((), (), ()),
) -> ::std::option::Option<(lexer::Token, ())>
{
    let __start0 = __0.0.clone();
    let __end0 = __1.2.clone();
    let __temp0 = __action68(
        __0,
        __1,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action66(
        __temp0,
    )
}

pub fn __action72<
    'input,
>(
    __0: ((), lexer::Token, ()),
    __1: ((), lexer::Token, ()),
    __2: ((), (), ()),
    __3: ((), lexer::Token, ()),
    __4: ((), (), ()),
    __5: ((), lexer::Token, ()),
    __6: ((), (), ()),
    __7: ((), lexer::Token, ()),
    __8: ((), lexer::Token, ()),
) -> Statement
{
    let __start0 = __5.0.clone();
    let __end0 = __6.2.clone();
    let __temp0 = __action71(
        __5,
        __6,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action69(
        __0,
        __1,
        __2,
        __3,
        __4,
        __temp0,
        __7,
        __8,
    )
}

pub fn __action73<
    'input,
>(
    __0: ((), lexer::Token, ()),
    __1: ((), lexer::Token, ()),
    __2: ((), (), ()),
    __3: ((), lexer::Token, ()),
    __4: ((), (), ()),
    __5: ((), lexer::Token, ()),
    __6: ((), lexer::Token, ()),
) -> Statement
{
    let __start0 = __4.2.clone();
    let __end0 = __5.0.clone();
    let __temp0 = __action67(
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action69(
        __0,
        __1,
        __2,
        __3,
        __4,
        __temp0,
        __5,
        __6,
    )
}

pub fn __action74<
    'input,
>(
    __0: ((), lexer::Token, ()),
    __1: ((), lexer::Token, ()),
    __2: ((), (), ()),
    __3: ((), lexer::Token, ()),
    __4: ((), (), ()),
    __5: ((), lexer::Token, ()),
    __6: ((), (), ()),
    __7: ((), lexer::Token, ()),
) -> Statement
{
    let __start0 = __5.0.clone();
    let __end0 = __6.2.clone();
    let __temp0 = __action71(
        __5,
        __6,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action70(
        __0,
        __1,
        __2,
        __3,
        __4,
        __temp0,
        __7,
    )
}

pub fn __action75<
    'input,
>(
    __0: ((), lexer::Token, ()),
    __1: ((), lexer::Token, ()),
    __2: ((), (), ()),
    __3: ((), lexer::Token, ()),
    __4: ((), (), ()),
    __5: ((), lexer::Token, ()),
) -> Statement
{
    let __start0 = __4.2.clone();
    let __end0 = __5.0.clone();
    let __temp0 = __action67(
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action70(
        __0,
        __1,
        __2,
        __3,
        __4,
        __temp0,
        __5,
    )
}

pub fn __action76<
    'input,
>(
    __0: ((), String, ()),
    __1: ((), lexer::Token, ()),
) -> ::std::option::Option<(String, lexer::Token)>
{
    let __start0 = __0.0.clone();
    let __end0 = __1.2.clone();
    let __temp0 = __action63(
        __0,
        __1,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action61(
        __temp0,
    )
}

pub fn __action77<
    'input,
>(
    __0: ((), String, ()),
    __1: ((), lexer::Token, ()),
    __2: ((), String, ()),
) -> ()
{
    let __start0 = __0.0.clone();
    let __end0 = __1.2.clone();
    let __temp0 = __action76(
        __0,
        __1,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action4(
        __temp0,
        __2,
    )
}

pub fn __action78<
    'input,
>(
    __0: ((), String, ()),
) -> ()
{
    let __start0 = __0.0.clone();
    let __end0 = __0.0.clone();
    let __temp0 = __action62(
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action4(
        __temp0,
        __0,
    )
}

pub fn __action79<
    'input,
>(
    __0: ((), lexer::Token, ()),
    __1: ((), String, ()),
    __2: ((), lexer::Token, ()),
    __3: ((), lexer::Token, ()),
    __4: ((), lexer::Token, ()),
    __5: ((), String, ()),
    __6: ((), lexer::Token, ()),
    __7: ((), (), ()),
) -> ()
{
    let __start0 = __7.0.clone();
    let __end0 = __7.2.clone();
    let __temp0 = __action59(
        __7,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action10(
        __0,
        __1,
        __2,
        __3,
        __4,
        __5,
        __6,
        __temp0,
    )
}

pub fn __action80<
    'input,
>(
    __0: ((), lexer::Token, ()),
    __1: ((), String, ()),
    __2: ((), lexer::Token, ()),
    __3: ((), lexer::Token, ()),
    __4: ((), lexer::Token, ()),
    __5: ((), String, ()),
    __6: ((), lexer::Token, ()),
) -> ()
{
    let __start0 = __6.2.clone();
    let __end0 = __6.2.clone();
    let __temp0 = __action60(
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action10(
        __0,
        __1,
        __2,
        __3,
        __4,
        __5,
        __6,
        __temp0,
    )
}

pub trait __ToTriple<'input, > {
    type Error;
    fn to_triple(value: Self) -> Result<((),lexer::Token,()),Self::Error>;
}

impl<'input, > __ToTriple<'input, > for lexer::Token {
    type Error = ();
    fn to_triple(value: Self) -> Result<((),lexer::Token,()),()> {
        Ok(((), value, ()))
    }
}
impl<'input, > __ToTriple<'input, > for Result<(lexer::Token),()> {
    type Error = ();
    fn to_triple(value: Self) -> Result<((),lexer::Token,()),()> {
        value.map(|v| ((), v, ()))
    }
}
