use ast::*;
use lexer::{self};

grammar<'input>;

extern {
    enum lexer::Token {
        "(" => lexer::Token::LeftBracket,
        ")" => lexer::Token::RightBracket,
        "," => lexer::Token::Comma,
        ";" => lexer::Token::Semicolon,
        "=" => lexer::Token::Equals,
        "." => lexer::Token::Period,

        ACTION => lexer::Token::ACTION,
        BIGINT => lexer::Token::BIGINT,
        BIGSERIAL => lexer::Token::BIGSERIAL,
        BIT => lexer::Token::BIT,
        BOOL => lexer::Token::BOOL,
        BOOLEAN => lexer::Token::BOOLEAN,
        CASCADE => lexer::Token::CASCADE,
        CONSTRAINT => lexer::Token::CONSTRAINT,
        CHAR => lexer::Token::CHAR,
        CHARACTER => lexer::Token::CHARACTER,
        CREATE => lexer::Token::CREATE,
        DATE => lexer::Token::DATE,
        DEFAULT => lexer::Token::DEFAULT,
        DELETE => lexer::Token::DELETE,
        DOUBLE => lexer::Token::DOUBLE,
        FILLFACTOR => lexer::Token::FILLFACTOR,
        FOREIGN => lexer::Token::FOREIGN,
        FULL => lexer::Token::FULL,
        INT => lexer::Token::INT,
        INT2 => lexer::Token::INT2,
        INT4 => lexer::Token::INT4,
        INT8 => lexer::Token::INT8,
        INTEGER => lexer::Token::INTEGER,
        KEY => lexer::Token::KEY,
        MATCH => lexer::Token::MATCH,
        MONEY => lexer::Token::MONEY,
        NO => lexer::Token::NO,
        NOT => lexer::Token::NOT,
        NULL => lexer::Token::NULL,
        NUMERIC => lexer::Token::NUMERIC,
        ON => lexer::Token::ON,
        PARTIAL => lexer::Token::PARTIAL,
        PRECISION => lexer::Token::PRECISION,
        PRIMARY => lexer::Token::PRIMARY,
        REAL => lexer::Token::REAL,
        REFERENCES => lexer::Token::REFERENCES,
        RESTRICT => lexer::Token::RESTRICT,
        SCHEMA => lexer::Token::SCHEMA,
        SERIAL => lexer::Token::SERIAL,
        SERIAL2 => lexer::Token::SERIAL2,
        SERIAL4 => lexer::Token::SERIAL4,
        SERIAL8 => lexer::Token::SERIAL8,
        SET => lexer::Token::SET,
        SIMPLE => lexer::Token::SIMPLE,
        SMALLINT => lexer::Token::SMALLINT,
        SMALLSERIAL => lexer::Token::SMALLSERIAL,
        TABLE => lexer::Token::TABLE,
        TEXT => lexer::Token::TEXT,
        TIME => lexer::Token::TIME,
        TIMESTAMP => lexer::Token::TIMESTAMP,
        TIMESTAMPTZ => lexer::Token::TIMESTAMPTZ,
        TIMETZ => lexer::Token::TIMETZ,
        UNIQUE => lexer::Token::UNIQUE,
        UPDATE => lexer::Token::UPDATE,
        UUID => lexer::Token::UUID,
        VARBIT => lexer::Token::VARBIT,
        VARCHAR => lexer::Token::VARCHAR,
        VARYING => lexer::Token::VARYING,
        WITH => lexer::Token::WITH,
        WITHOUT => lexer::Token::WITHOUT,
        ZONE => lexer::Token::ZONE,
        
        Ident => lexer::Token::Identifier(<String>),
        Digit => lexer::Token::Digit(<i32>),
    }
}

pub statement_list: Vec<Statement> = {
    <v:statement_list> <stmt:statement> => {
        let mut v = v;
        v.push(stmt);
        v
    },
    <statement> => vec!(<>),
};

statement: Statement = {
    CREATE TABLE <name:table_name> "(" <columns:column_definition_list> "," <table_constraints:table_constraint_list> ")" ";"? => Statement::Table(TableDefinition {
        name: name,
        columns: columns,
        constraints: Some(table_constraints),
    }),
    CREATE TABLE <name:table_name> "(" <columns:column_definition_list> ")" ";"? => Statement::Table(TableDefinition {
        name: name,
        columns: columns,
        constraints: None,
    }),
    CREATE SCHEMA <name:Ident> ";"? => Statement::Schema(SchemaDefinition {
        name: name,
    }),
};

table_name: TableName = {
    <schema:Ident> "." <name:Ident> => TableName { schema: Some(schema), name: name },
    <name:Ident> => TableName { schema: None, name: name },
};

column_definition_list: Vec<ColumnDefinition> = {
    <v:column_definition_list> "," <c:column_definition> => {
        let mut v = v;
        v.push(c);
        v
    },
    <column_definition> => vec!(<>)
};

column_definition: ColumnDefinition = {
    <name:Ident> <t:sql_type> <constraints:column_constraint_list?> => ColumnDefinition {
        name: name,
        sql_type: t,
        constraints: constraints,
    },
};

column_list: Vec<String> = {
    <v:column_list> "," <c:Ident> => {
        let mut v = v;
        v.push(c);
        v
    },
    <Ident> => vec!(<>),
};

table_constraint_list: Vec<TableConstraint> = {
    <v:table_constraint_list> "," <c:table_constraint> => {
        let mut v = v;
        v.push(c);
        v
    },
    <table_constraint> => vec!(<>),
};

table_constraint: TableConstraint = {
    CONSTRAINT <name:Ident> PRIMARY KEY "(" <columns:column_list> ")" <parameters:index_parameters?> => TableConstraint::Primary { 
        name: name, 
        columns: columns, 
        parameters: parameters 
    },
    CONSTRAINT <name:Ident> FOREIGN KEY "(" <columns:column_list> ")" REFERENCES <ref_table:table_name> "(" <ref_columns:column_list> ")" <match_type:match_type?> <events:constraint_events?> => TableConstraint::Foreign { 
        name: name, 
        columns: columns, 
        ref_table: ref_table, 
        ref_columns: ref_columns,
        match_type: match_type,
        events: events,
    }, 
};

index_parameters: Vec<IndexParameter> = {
    WITH "(" <index_parameter_list> ")" => <>,
};

index_parameter_list: Vec<IndexParameter> = {
    <v:index_parameter_list> "," <i:index_parameter> => {
        let mut v = v;
        v.push(i);
        v
    },
    <index_parameter> => vec!(<>),
};

index_parameter: IndexParameter = {
    FILLFACTOR "=" <Digit> => IndexParameter::FillFactor(<> as u32),
};

match_type: ForeignConstraintMatchType = {
    MATCH SIMPLE => ForeignConstraintMatchType::Simple,
    MATCH PARTIAL => ForeignConstraintMatchType::Partial,
    MATCH FULL => ForeignConstraintMatchType::Full,
};

constraint_events: Vec<ForeignConstraintEvent> = {
    <v:constraint_events> <e:constraint_event> => {
        let mut v = v;
        v.push(e);
        v
    },
    <constraint_event> => vec!(<>),
};

constraint_event: ForeignConstraintEvent = {
    ON DELETE <foreign_constraint_action> => ForeignConstraintEvent::Delete(<>),
    ON UPDATE <foreign_constraint_action> => ForeignConstraintEvent::Update(<>),
};

foreign_constraint_action: ForeignConstraintAction = {
    NO ACTION => ForeignConstraintAction::NoAction,
    RESTRICT => ForeignConstraintAction::Restrict,
    CASCADE => ForeignConstraintAction::Cascade,
    SET NULL => ForeignConstraintAction::SetNull,
    SET DEFAULT => ForeignConstraintAction::SetDefault,
};

sql_type: SqlType = {
    CHAR "(" <Digit> ")" => SqlType::FixedLengthString(<> as u32),
    CHARACTER "(" <Digit> ")" => SqlType::FixedLengthString(<> as u32),
    VARCHAR "(" <Digit> ")" => SqlType::VariableLengthString(<> as u32),
    CHARACTER VARYING "(" <Digit> ")" => SqlType::VariableLengthString(<> as u32),
    TEXT => SqlType::Text,

    BIT "(" <Digit> ")" => SqlType::FixedLengthBitString(<> as u32),
    VARBIT "(" <Digit> ")" => SqlType::VariableLengthBitString(<> as u32),
    BIT VARYING "(" <Digit> ")" => SqlType::VariableLengthBitString(<> as u32),
    SMALLINT => SqlType::SmallInteger,
    INT => SqlType::Integer,
    INTEGER => SqlType::Integer,
    BIGINT => SqlType::BigInteger,
    INT2 => SqlType::SmallInteger,
    INT4 => SqlType::Integer,
    INT8 => SqlType::BigInteger,

    SMALLSERIAL => SqlType::SmallSerial,
    SERIAL => SqlType::Serial,
    BIGSERIAL => SqlType::BigSerial,
    SERIAL2 => SqlType::SmallSerial,
    SERIAL4 => SqlType::Serial,
    SERIAL8 => SqlType::BigSerial,

    NUMERIC "(" <m:Digit> "," <d:Digit> ")" => SqlType::Numeric(m as u32, d as u32),
    DOUBLE PRECISION => SqlType::Double,
    REAL => SqlType::Single,
    MONEY => SqlType::Money,
    BOOL => SqlType::Boolean,
    BOOLEAN => SqlType::Boolean,

    DATE => SqlType::Date,
    TIMESTAMP => SqlType::DateTime,
    TIMESTAMP WITHOUT TIME ZONE => SqlType::DateTime,
    TIMESTAMP WITH TIME ZONE => SqlType::DateTimeWithTimeZone,
    TIMESTAMPTZ => SqlType::DateTimeWithTimeZone,
    TIME => SqlType::Time,
    TIME WITHOUT TIME ZONE => SqlType::Time,
    TIME WITH TIME ZONE => SqlType::TimeWithTimeZone,
    TIMETZ => SqlType::TimeWithTimeZone,
    
    UUID => SqlType::Uuid,

    <Ident> => SqlType::Custom(<>),
};

column_constraint_list: Vec<ColumnConstraint> = {
    <v:column_constraint_list> <q:column_constraint> => {
        let mut v = v;
        v.push(q);
        v
    },
    <column_constraint> => vec!(<>),
};

column_constraint: ColumnConstraint = {
    NULL => ColumnConstraint::Null,
    NOT NULL => ColumnConstraint::NotNull,
    UNIQUE => ColumnConstraint::Unique,
    PRIMARY KEY => ColumnConstraint::PrimaryKey,
};